<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spirit Aquarium</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Patrick+Hand&display=swap');

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #2b3a42;
            font-family: 'Patrick Hand', cursive;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-top {
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            pointer-events: auto;
        }

        .score-group {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .score-container {
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(5px);
            padding: 10px 25px;
            border-radius: 50px;
            color: #fff;
            font-size: 24px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .button-group {
            display: flex;
            gap: 10px;
        }

        .mode-btn {
            background: rgba(255, 255, 255, 0.9);
            border: none;
            padding: 10px 20px;
            border-radius: 30px;
            font-family: 'Patrick Hand', cursive;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .mode-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }

        .mode-btn.active {
            background: #a4dddb;
            color: #16252B;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.1);
        }

        .currency-icon {
            width: 20px;
            height: 20px;
            background: radial-gradient(circle at 30% 30%, #fff, #a4dddb);
            border-radius: 50%;
            box-shadow: 0 0 10px #a4dddb;
        }

        .bottom-ui {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: auto;
            pointer-events: none;
        }

        .shop-container {
            pointer-events: auto;
            background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
            padding: 20px;
            display: flex;
            gap: 15px;
            overflow-x: auto;
            align-items: flex-end;
            padding-bottom: 30px;
            padding-right: 280px; 
            scrollbar-width: none;
        }
        
        .shop-container::-webkit-scrollbar {
            display: none;
        }

        .graveyard-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 220px;
            max-height: 200px; 
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
            border-radius: 12px;
            padding: 15px;
            color: #ddd;
            pointer-events: auto;
            overflow-y: auto;
            border: 1px solid rgba(255,255,255,0.1);
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .graveyard-container::-webkit-scrollbar {
            width: 6px;
        }
        .graveyard-container::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
        }
        .graveyard-container::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.3);
            border-radius: 3px;
        }

        .graveyard-title {
            font-size: 18px;
            color: #a4dddb;
            border-bottom: 1px solid rgba(255,255,255,0.2);
            padding-bottom: 5px;
            margin-bottom: 5px;
            position: sticky;
            top: 0;
            background: rgba(0,0,0,0.0);
            backdrop-filter: blur(0);
        }

        .tombstone {
            font-size: 14px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            padding-bottom: 4px;
            flex-shrink: 0; 
        }

        .tombstone span {
            display: block;
            font-size: 12px;
            color: #888;
        }

        .fish-card {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            padding: 10px;
            min-width: 100px;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s, filter 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            position: relative;
            opacity: 0.8;
            border: 2px solid transparent;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .fish-card:hover {
            transform: translateY(-10px);
            opacity: 1;
            z-index: 10;
        }

        .fish-card.locked {
            background: rgba(100, 100, 100, 0.5);
            cursor: not-allowed;
            filter: grayscale(1);
        }

        .fish-card.affordable {
            border-color: #88e1d5;
            box-shadow: 0 0 15px rgba(136, 225, 213, 0.5);
        }

        .fish-preview-canvas {
            margin-bottom: 5px;
        }

        .fish-name {
            font-size: 16px;
            color: #333;
            font-weight: bold;
        }

        .fish-cost {
            font-size: 14px;
            color: #666;
        }

        #toast {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .tutorial-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255,255,255,0.8);
            font-size: 24px;
            pointer-events: none;
            animation: fadeOut 5s forwards;
            animation-delay: 3s;
            text-align: center;
        }

        @keyframes fadeOut {
            to { opacity: 0; }
        }

    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="score-group">
                <div class="score-container">
                    <div class="currency-icon"></div>
                    <span id="scoreDisplay">0</span>
                </div>
            </div>
            
            <div class="button-group">
                <button id="autoFeedBtn" class="mode-btn" onclick="toggleAutoFeed()">
                    üçÇ Auto Feed: OFF
                </button>
                <button id="talkBtn" class="mode-btn" onclick="toggleTalkMode()">
                    ‚ú® Talk to Spirits
                </button>
            </div>
        </div>
        
        <div id="toast">Summoning...</div>
        <div class="tutorial-text">Click to feed the spirits...</div>

        <div class="bottom-ui">
            <div class="shop-container" id="shopContainer"></div>
            <div class="graveyard-container" id="graveyardList">
                <div class="graveyard-title">Spirit Memories</div>
            </div>
        </div>
    </div>

    <script>
        // --- Fallback Data (Ghibli Style) ---
        const FALLBACK_NAMES = [
            // Classics
            "Chihiro", "Haku", "Totoro", "Kiki", "Jiji", "Ponyo", "Sosuke", "Sophie", "Howl", "Calcifer", 
            "Markl", "Nausicaa", "Sheeta", "Pazu", "San", "Ashitaka", "Yubaba", "Kamaji", "Lin", "No-Face", 
            // The Cat Returns / Whisper of the Heart
            "Baron", "Muta", "Haru", "Seiji", "Shizuku", "Natori", "Nao", "Toto",
            // Arrietty / Marnie / Poppy Hill
            "Arrietty", "Spiller", "Marnie", "Anna", "Umi", "Shun", "Pod", "Homily", "Sadako",
            // Princess Mononoke Deep Cuts
            "Yakul", "Moro", "Okami", "Nago", "Okkoto", "Gonza", "Toki", "Eboshi", "Jigo", "Kaya", "Hii-sama", "Kohroku",
            // Spirited Away Extras
            "Zeniba", "Boh", "Aogaeru", "Bandai-gaeru", "Chichiyaku", "Aniyaku",
            // Howl's Extras
            "Turnip", "Heen", "Lettie", "Honey", "Suliman",
            // Earthsea
            "Arren", "Therru", "Sparrowhawk", "Ged", "Tenar", "Tehanu", "Cob", "Hare",
            // Wind Rises
            "Jiro", "Nahoko", "Caproni", "Castorp", "Honjo", "Kayo",
            // Ponyo Extras
            "Fujimoto", "Granmamare", "Lisa", "Koichi", "Toki", "Yoshie", "Noriko", "Kumiko", "Karen",
            // Kiki Extras
            "Tombo", "Osono", "Fukuo", "Ursula", "Ket", "Maki", "Madame", "Barsa",
            // Laputa Extras
            "Dola", "Charles", "Louis", "Henri", "Motro", "Okami", "Muska", "Uncle Pom"
        ];

        const FALLBACK_PHRASES = {
            'curious and bubbly': [
                "Sparkles!", "Bloop bloop!", "Is that food?", "Yum yum!", "Friend?", "Swimming!", 
                "Happy bubbles!", "So shiny!", "Did you see that?", "Round and round!", "Tee hee!", 
                "Water is nice!", "Hello up there!", "Wiggle wiggle.", "Play with me!", "I found a bubble!"
            ],
            'playful, clicking, and mysterious': [
                "Click...", "Echoes...", "Hide and seek?", "Catch me!", "Spirits whisper...", 
                "Tee hee!", "Invisible...", "You can't see me.", "Secrets...", "The water remembers.", 
                "Pop!", "Do you know the way?", "Turning...", "Softly now.", "I am here... and there."
            ],
            'slow, wise, and sleepy': [
                "The river knows...", "Zzz...", "Currents shift...", "Patience...", "Drifting...", 
                "Ancient waters...", "Rest now.", "Time flows like water.", "Hrmmm...", "No rush.", 
                "The moss grows slow.", "Quiet thoughts.", "Deep breaths.", "Sleepy tides.", "A long journey."
            ],
            'majestic, ancient, and noble': [
                "Behold.", "The deep calls.", "Golden light.", "Respect the water.", "I watch over all.", 
                "Grace.", "Silence.", "The sky reflects here.", "Do not disturb the flow.", "I have seen ages.", 
                "Noble currents.", "Rise above.", "Tranquility.", "The spirits are watching.", "Pure waters."
            ],
            'silent, hungry, and eerie': [
                "...", "Ah... ah...", "Gold...", "Hungry...", "Feed me...", "Lonely...", 
                "Empty...", "Want...", "More...", "Darkness...", "Cold...", "Waiting...", 
                "Give...", "Shadow...", "Lost..."
            ],
            'energetic, starlike, and fast': [
                "Zoom!", "Twinkle!", "Shooting star!", "Catch me!", "Light!", "Speed!", 
                "Zap!", "Faster!", "Can't stop!", "Glowing!", "Look at me!", "Whoosh!", 
                "Bright!", "Starlight!", "Burning bright!"
            ],
            'aggressive, hunting, and sharp': [
                "Prey...", "Shadows...", "Snap!", "Watching...", "Hunger...", "Darkness...", 
                "Closer...", "Hunt.", "Sharp teeth.", "Silent stalker.", "Fear me.", "Blood in the water.", 
                "My domain.", "Trespasser.", "Got you."
            ],
            'massive, slow, and insatiable': [
                "Gulp.", "Ancient hunger.", "Floating...", "Everything is food.", "Slowly...", 
                "Grow...", "Endless...", "Mouth open.", "Drift to me.", "Heavy...", "Big water.", 
                "Swallow whole.", "Deep belly.", "River god.", "Mountain of flesh."
            ]
        };

        // --- Gemini API Integration ---
        const apiKey = ""; // Injected by environment

        async function callGemini(prompt) {
            if (!apiKey) return null; 

            const delays = [1000, 2000, 4000];
            
            for (let attempt = 0; attempt <= 2; attempt++) {
                try {
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: prompt }] }]
                        })
                    });
                    
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    
                    const data = await response.json();
                    return data.candidates?.[0]?.content?.parts?.[0]?.text?.trim();
                } catch (e) {
                    console.warn("Gemini API attempt failed, using fallback later.");
                    await new Promise(resolve => setTimeout(resolve, delays[attempt]));
                }
            }
            return null;
        }

        // --- Configuration & Assets ---
        const CONFIG = {
            colors: {
                waterTop: '#2F5A6E',
                waterBottom: '#16252B',
                ray: 'rgba(255, 255, 255, 0.03)',
                food: '#E8B67D',
                caustic: 'rgba(164, 221, 219, 0.05)'
            },
            physics: {
                friction: 0.96,
                turnSpeed: 0.08,
                foodGravity: 0.8
            }
        };

        // Species list ordered by ascending cost for shop display
        const SPECIES = [
            {
                id: 'basic',
                name: 'River Spirit',
                cost: 100,
                colorBody: '#E86F51', 
                colorFin: '#F4A261',
                size: 15,
                speed: 2.5,
                finType: 'simple',
                personality: 'curious and bubbly'
            },
            {
                id: 'starbit',
                name: 'Star Bit Guppy',
                cost: 250,
                colorBody: '#FFD93D', 
                colorFin: '#FFF',
                size: 10,
                speed: 4.0,
                finType: 'simple',
                personality: 'energetic, starlike, and fast'
            },
            {
                id: 'kodama',
                name: 'Kodama Tetra',
                cost: 350,
                colorBody: '#F1FAEE', 
                colorFin: '#A8DADC',
                size: 12,
                speed: 3.5,
                finType: 'glow',
                personality: 'playful, clicking, and mysterious'
            },
            {
                id: 'forest',
                name: 'Mossy Carp',
                cost: 800,
                colorBody: '#457B9D', 
                colorFin: '#1D3557',
                size: 25,
                speed: 1.8,
                finType: 'flowing',
                personality: 'slow, wise, and sleepy'
            },
            {
                id: 'hunter',
                name: 'Shadow Hunter',
                cost: 1200,
                colorBody: '#2C3E50',
                colorFin: '#E74C3C',
                size: 30,
                speed: 3.8,
                finType: 'fancy',
                personality: 'aggressive, hunting, and sharp',
                isPredator: true
            },
            {
                id: 'sun',
                name: 'Sky Spirit',
                cost: 2000,
                colorBody: '#fff', 
                colorFin: '#48CAE4',
                size: 35,
                speed: 3.0,
                finType: 'flowing',
                personality: 'majestic, ancient, and noble'
            },
            {
                id: 'lord',
                name: 'River Lord',
                cost: 5000,
                colorBody: '#4A5568',
                colorFin: '#2D3748',
                size: 60,
                speed: 1.2,
                finType: 'flowing',
                personality: 'massive, slow, and insatiable',
                isPredator: true
            }
        ];

        // --- Game State ---
        let canvas, ctx;
        let width, height;
        let score = 0;
        let particles = [];
        let fishes = [];
        let ripples = [];
        let lastTime = 0;
        let isTalkMode = false;
        let isAutoFeed = false;
        let autoFeedTimer = null;
        let mousePos = { x: -9999, y: -9999 };

        // --- Classes ---

        class Vector {
            constructor(x, y) { this.x = x; this.y = y; }
            add(v) { this.x += v.x; this.y += v.y; }
            sub(v) { this.x -= v.x; this.y -= v.y; }
            mult(n) { this.x *= n; this.y *= n; }
            div(n) { if(n!==0) { this.x /= n; this.y /= n; } }
            mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
            magSq() { return this.x * this.x + this.y * this.y; }
            normalize() {
                let m = this.mag();
                if (m !== 0) this.mult(1/m);
            }
            limit(max) {
                if (this.magSq() > max * max) {
                    this.normalize();
                    this.mult(max);
                }
            }
            static sub(v1, v2) { return new Vector(v1.x - v2.x, v1.y - v2.y); }
            static distSq(v1, v2) {
                let dx = v1.x - v2.x;
                let dy = v1.y - v2.y;
                return dx*dx + dy*dy;
            }
        }

        const distSq = (x1, y1, x2, y2) => (x2 - x1)**2 + (y2 - y1)**2;
        const dist = (x1, y1, x2, y2) => Math.sqrt(distSq(x1, y1, x2, y2));

        class Ripple {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 1;
                this.maxRadius = 60;
                this.opacity = 0.6;
                this.speed = 1.5;
            }
            update() {
                this.radius += this.speed;
                this.opacity -= 0.01;
            }
            draw(ctx) {
                if(this.opacity <= 0) return;
                ctx.beginPath();
                ctx.strokeStyle = `rgba(255, 255, 255, ${this.opacity})`;
                ctx.lineWidth = 2;
                ctx.ellipse(this.x, this.y, this.radius, this.radius * 0.6, 0, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        class Food {
            constructor(x, y) {
                this.pos = new Vector(x, y);
                this.vel = new Vector(0, 0);
                this.acc = new Vector(0, CONFIG.physics.foodGravity * 0.1);
                this.size = 4;
                this.eaten = false;
                
                // Natural drift properties
                this.wobbleSpeed = rand(0.002, 0.005);
                this.wobbleDist = rand(0.2, 0.6);
                this.timeOffset = rand(0, 1000);
            }
            update() {
                this.vel.add(this.acc);
                this.vel.mult(0.95); 
                this.pos.add(this.vel);
                
                // Side to side drift
                this.pos.x += Math.sin(Date.now() * this.wobbleSpeed + this.timeOffset) * this.wobbleDist;
                
                if (this.pos.y > height) this.eaten = true; 
            }
            draw(ctx) {
                ctx.fillStyle = CONFIG.colors.food;
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class Bubble {
            constructor() {
                this.reset();
                this.y = rand(height, height + 200);
            }
            reset() {
                this.x = rand(0, width);
                this.y = height + 10;
                this.size = rand(1, 4);
                this.speed = rand(0.5, 2);
                this.wobble = rand(0, Math.PI * 2);
            }
            update() {
                this.y -= this.speed;
                this.x += Math.sin(Date.now() * 0.002 + this.wobble) * 0.5;
                if (this.y < -10) this.reset();
            }
            draw(ctx) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class Fish {
            constructor(type, isBorn = false) {
                this.species = type;
                this.name = "Spirit"; 
                this.pos = new Vector(rand(100, width - 100), rand(100, height - 100));
                this.vel = new Vector(rand(-1, 1), rand(-1, 1));
                this.acc = new Vector(0, 0);
                this.angle = Math.random() * Math.PI * 2;
                
                this.maxSpeed = type.speed;
                this.maxForce = 0.1; 
                this.size = type.size;
                
                this.birthTime = Date.now();
                // Lifespan: 1 hour to 24 hours
                this.lifespan = rand(60 * 60 * 1000, 24 * 60 * 60 * 1000); 
                this.isDead = false;
                this.isEaten = false; 
                
                this.energy = 100; 
                this.maxEnergy = 100;

                this.digestionSlowdown = 1.0; 
                
                this.tailAngle = 0;
                this.tailSpeed = 0.2;
                
                this.chatText = null;
                this.chatTimer = 0;
                this.isTalking = false;

                this.romanceTarget = null; // Current target for reproduction

                // MATURITY LOGIC FIX
                if (!isBorn) {
                    // Bought fish are adults:
                    // 1. Backdate birthTime by 2 minutes so they pass the maturity check (> 1 min) immediately
                    this.birthTime -= 120 * 1000;
                    // 2. Clear cooldown so they can mate immediately
                    this.lastReproductionTime = 0; 
                } else {
                    // Born fish start fresh and must wait
                    this.lastReproductionTime = Date.now(); 
                }

                this.generateName();
            }

            async generateName() {
                const prompt = `Generate a single, short, whimsical, Studio Ghibli-style name for a water spirit that looks like a ${this.species.name}. It should be unique and sound magical. Return ONLY the name, no other text.`;
                const newName = await callGemini(prompt);
                if (newName) this.name = newName;
                else this.name = FALLBACK_NAMES[Math.floor(Math.random() * FALLBACK_NAMES.length)];
            }

            async talk() {
                if (this.isTalking || this.isDead) return;
                this.isTalking = true;
                this.chatText = "...";
                const prompt = `Roleplay as a ${this.species.name} named ${this.name} in a magical Ghibli aquarium. Your personality is ${this.species.personality}. A human just waved at you. Respond with one very short, poetic, funny, or mystical sentence (max 10 words).`;
                const response = await callGemini(prompt);
                
                if (response) this.chatText = response;
                else {
                    const phrases = FALLBACK_PHRASES[this.species.personality] || ["Bloop?", "Hello...", "Splosh."];
                    this.chatText = phrases[Math.floor(Math.random() * phrases.length)];
                }
                this.chatTimer = 300;
                this.isTalking = false;
            }

            reproduce(mate) {
                const numOffspring = Math.floor(rand(1, 4)); 
                const spawnPos = new Vector((this.pos.x + mate.pos.x) / 2, (this.pos.y + mate.pos.y) / 2);
                
                showToast(`New Spirits! ${this.name} and ${mate.name} welcome ${numOffspring} babies.`);

                for (let i = 0; i < numOffspring; i++) {
                    // Pass true to indicate this is a newborn
                    const child = new Fish(this.species, true);
                    child.pos = new Vector(spawnPos.x + rand(-5,5), spawnPos.y + rand(-5,5)); // Mild offset
                    child.size = this.species.size * 0.2; 
                    child.maxSpeed *= 1.5; 
                    // Babies inherit cooldown so they can't breed immediately
                    child.lastReproductionTime = Date.now() + rand(5 * 60 * 1000, 10 * 60 * 1000);
                    fishes.push(child);
                    
                    for(let j=0; j<10; j++) {
                        if(particles.length < 300) {
                            particles.push({
                                x: spawnPos.x, y: spawnPos.y,
                                vx: rand(-2,2), vy: rand(-2,2),
                                life: 1.0, color: '#A4DDBB' 
                            });
                        }
                    }
                }

                const cooldown = rand(5 * 60 * 1000, 10 * 60 * 1000);
                this.lastReproductionTime = Date.now() + cooldown;
                mate.lastReproductionTime = Date.now() + cooldown;
                
                // Reset targets
                this.romanceTarget = null;
                mate.romanceTarget = null;
            }

            flock(boids) {
                let sep = new Vector(0, 0);
                let ali = new Vector(0, 0);
                let coh = new Vector(0, 0);
                let sepCount = 0, aliCount = 0, cohCount = 0;
                const desiredSeparationSq = (40 + this.size)**2;
                const neighborDistSq = 100**2;

                for (let other of boids) {
                    if (other === this || other.isDead) continue;
                    let dSq = Vector.distSq(this.pos, other.pos);
                    if (dSq > 0 && dSq < desiredSeparationSq) {
                        let diff = Vector.sub(this.pos, other.pos);
                        diff.normalize();
                        diff.div(Math.sqrt(dSq)); 
                        sep.add(diff);
                        sepCount++;
                    }
                    if (dSq > 0 && dSq < neighborDistSq) {
                        let factor = (other.species.id === this.species.id) ? 2.0 : 0.5;
                        let alignVel = new Vector(other.vel.x, other.vel.y);
                        alignVel.mult(factor);
                        ali.add(alignVel);
                        aliCount++;
                        let cohPos = new Vector(other.pos.x, other.pos.y);
                        coh.add(cohPos);
                        cohCount++;
                    }
                }
                if (sepCount > 0) {
                    sep.div(sepCount); sep.normalize(); sep.mult(this.maxSpeed); sep.sub(this.vel); sep.limit(this.maxForce * 2.0);
                }
                if (aliCount > 0) {
                    ali.div(aliCount); ali.normalize(); ali.mult(this.maxSpeed); ali.sub(this.vel); ali.limit(this.maxForce);
                }
                if (cohCount > 0) {
                    coh.div(cohCount);
                    let desired = Vector.sub(coh, this.pos);
                    desired.normalize(); desired.mult(this.maxSpeed);
                    let steer = Vector.sub(desired, this.vel); steer.limit(this.maxForce);
                    coh = steer;
                }
                sep.mult(1.5); ali.mult(1.0); coh.mult(1.0);
                this.acc.add(sep); this.acc.add(ali); this.acc.add(coh);
            }

            hunt(allFish) {
                if (!this.species.isPredator || this.isDead) return null;
                let closestPrey = null;
                let closestDistSq = Infinity;
                let rangeSq = 300**2;

                for (let prey of allFish) {
                    if (prey !== this && !prey.isDead && prey.size < this.size * 0.6) {
                        let dSq = Vector.distSq(this.pos, prey.pos);
                        if (dSq < (this.size * 0.8)**2) return prey; 
                        if (dSq < rangeSq && dSq < closestDistSq) {
                            closestDistSq = dSq;
                            closestPrey = prey;
                        }
                    }
                }
                if (closestPrey) {
                    let desired = new Vector(closestPrey.pos.x - this.pos.x, closestPrey.pos.y - this.pos.y);
                    desired.normalize(); desired.mult(this.maxSpeed * 1.2); 
                    let steer = Vector.sub(desired, this.vel); steer.limit(this.maxForce * 1.5);
                    this.acc.add(steer);
                }
                return null;
            }

            update(foodList, allFish) {
                if (!this.isDead) {
                    this.energy -= 0.006;
                    if (this.digestionSlowdown < 1.0) this.digestionSlowdown += 0.002;

                    // --- Romance & Reproduction ---
                    const maturityAge = 60 * 1000;
                    const minCooldown = 5 * 60 * 1000;
                    
                    // 1. Check if existing target is still valid
                    if (this.romanceTarget) {
                        if (this.romanceTarget.isDead || 
                            this.energy < 80 || 
                            this.romanceTarget.energy < 80 ||
                            Vector.distSq(this.pos, this.romanceTarget.pos) > 300**2) {
                            this.romanceTarget = null; // Break up
                        }
                    }

                    // 2. Try to find a mate (throttled)
                    if (!this.romanceTarget && Math.random() < 0.02 && fishes.length <= 50) {
                        if (Date.now() - this.birthTime > maturityAge &&
                            Date.now() - this.lastReproductionTime > minCooldown && 
                            this.energy >= 80) {
                            
                            let potentialMate = allFish.find(other => 
                                other !== this && 
                                other.species.id === this.species.id && 
                                other.energy >= 80 && 
                                Date.now() - other.birthTime > maturityAge && 
                                Date.now() - other.lastReproductionTime > minCooldown &&
                                distSq(this.pos.x, this.pos.y, other.pos.x, other.pos.y) < 200**2 // Sensing range
                            );

                            if (potentialMate) {
                                this.romanceTarget = potentialMate;
                            }
                        }
                    }

                    // Death Checks
                    if (Date.now() - this.birthTime > this.lifespan || this.energy <= 0) {
                        this.isDead = true;
                        this.deathReason = this.energy <= 0 ? "Starved" : "Old Age";
                    }
                    if (Math.random() < 0.0000005) {
                        this.isDead = true;
                        this.deathReason = "Sudden Illness";
                    }
                }

                if (this.species.isPredator) {
                    let eatenPrey = this.hunt(allFish);
                    if (eatenPrey) {
                        eatenPrey.isDead = true;
                        eatenPrey.deathReason = `Eaten by ${this.name}`;
                        eatenPrey.isEaten = true; 
                        this.feed();
                    }
                }

                if (this.isDead) {
                    if (this.isEaten) return 'eaten'; 
                    this.vel.x *= 0.9; 
                    this.vel.y = -1.5; 
                    let targetAngle = Math.PI;
                    this.angle += (targetAngle - this.angle) * 0.02;
                    this.pos.add(this.vel);
                    if (this.pos.y < -50) return 'gone';
                    return 'alive';
                }

                if (this.chatTimer > 0 && !this.isTalking) {
                    this.chatTimer--;
                    if (this.chatTimer <= 0) this.chatText = null;
                }

                let target = null;
                let closestDistSq = Infinity;
                let closestFood = null;
                let searchRadSq = 300**2;

                for (let f of foodList) {
                    if (!f.eaten) {
                        let dSq = Vector.distSq(this.pos, f.pos);
                        if (dSq < searchRadSq && dSq < closestDistSq) {
                            closestDistSq = dSq;
                            closestFood = f;
                        }
                    }
                }

                if (closestFood) {
                    target = closestFood.pos;
                    let eatDist = this.size + 5;
                    if (closestDistSq < eatDist*eatDist) {
                        closestFood.eaten = true;
                        this.feed();
                    }
                }

                // Prioritize Food, then Romance, then Flocking
                if (target) {
                    this.seek(target);
                } else if (this.romanceTarget) {
                    this.seek(this.romanceTarget.pos);
                    // Check for close contact to spawn
                    if (distSq(this.pos.x, this.pos.y, this.romanceTarget.pos.x, this.romanceTarget.pos.y) < (this.size + this.romanceTarget.size)**2) {
                         this.reproduce(this.romanceTarget);
                    }
                } else {
                    this.flock(allFish);
                    this.wander(); 
                    this.boundaries();
                }

                this.vel.add(this.acc);
                
                let dToMouseSq = Vector.distSq(this.pos, mousePos);
                let speedMod = 1;
                
                // CONDITIONAL HOVER SLOWDOWN
                // Only apply slowdown if we are in "Talk to Spirits" mode
                if (isTalkMode && dToMouseSq < 150**2) {
                    speedMod = 0.3;
                }

                let energyFactor = Math.max(0.2, this.energy / this.maxEnergy);
                speedMod *= energyFactor;
                speedMod *= this.digestionSlowdown;

                this.vel.limit(this.maxSpeed * (target ? 1.5 : 1) * speedMod);
                this.pos.add(this.vel);
                this.acc.mult(0); 

                if (this.pos.x < this.size) { this.pos.x = this.size; this.vel.x *= -0.8; }
                if (this.pos.x > width - this.size) { this.pos.x = width - this.size; this.vel.x *= -0.8; }
                if (this.pos.y < this.size) { this.pos.y = this.size; this.vel.y *= -0.8; }
                if (this.pos.y > height - this.size) { this.pos.y = height - this.size; this.vel.y *= -0.8; }
                
                let desiredAngle = Math.atan2(this.vel.y, this.vel.x);
                let diff = desiredAngle - this.angle;
                while (diff < -Math.PI) diff += Math.PI * 2;
                while (diff > Math.PI) diff -= Math.PI * 2;
                this.angle += diff * CONFIG.physics.turnSpeed;

                let speedPct = this.vel.mag() / (this.maxSpeed || 1);
                this.tailSpeed = 0.1 + (speedPct * 0.3);
                this.tailAngle += this.tailSpeed;

                return 'alive';
            }

            seek(target) {
                let desired = new Vector(target.x - this.pos.x, target.y - this.pos.y);
                desired.normalize();
                desired.mult(this.maxSpeed);
                let steer = Vector.sub(desired, this.vel);
                steer.limit(this.maxForce);
                this.acc.add(steer);
            }

            wander() {
                let wanderR = 50;
                let wanderD = 100;
                let circlePos = new Vector(this.vel.x, this.vel.y);
                circlePos.normalize();
                circlePos.mult(wanderD);
                circlePos.add(this.pos);
                let t = Date.now() * 0.001 + this.pos.x; 
                let h = Math.sin(t) * wanderR;
                let target = new Vector(circlePos.x + Math.cos(t)*20, circlePos.y + h);
                this.seek(target);
            }

            boundaries() {
                let margin = 100;
                let desired = null;
                if (this.pos.x < margin) desired = new Vector(this.maxSpeed, this.vel.y);
                else if (this.pos.x > width - margin) desired = new Vector(-this.maxSpeed, this.vel.y);
                if (this.pos.y < margin) desired = new Vector(this.vel.x, this.maxSpeed);
                else if (this.pos.y > height - margin) desired = new Vector(this.vel.x, -this.maxSpeed);
                if (desired) {
                    desired.normalize();
                    desired.mult(this.maxSpeed);
                    let steer = Vector.sub(desired, this.vel);
                    steer.limit(this.maxForce * 2);
                    this.acc.add(steer);
                }
            }

            feed() {
                if (this.isDead) return;
                score += 15;
                updateScore();
                this.energy = Math.min(this.maxEnergy, this.energy + 30);
                this.digestionSlowdown = 0.5; 

                const maxSize = this.species.size * 3.0; 
                if (this.size < maxSize) {
                    this.size += 0.8; 
                    this.maxSpeed = Math.max(this.species.speed * 0.5, this.maxSpeed - 0.02);
                }

                for(let i=0; i<5; i++) {
                    if (particles.length < 300) {
                        particles.push({
                            x: this.pos.x, y: this.pos.y,
                            vx: rand(-1,1), vy: rand(-1,1),
                            life: 1.0, color: '#fff'
                        });
                    }
                }
            }

            draw(ctx) {
                if (this.isDead && this.isEaten) return;

                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);

                if (this.chatText && !this.isDead && this.size > 0) {
                    ctx.save();
                    ctx.translate(0, -this.size * 2 - 20);
                    ctx.font = "16px 'Patrick Hand'";
                    let metrics = ctx.measureText(this.chatText);
                    let w = metrics.width + 20;
                    let h = 30;
                    ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
                    ctx.beginPath();
                    ctx.roundRect(-w/2, -h/2, w, h, 10);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(-5, h/2);
                    ctx.lineTo(5, h/2);
                    ctx.lineTo(0, h/2 + 6);
                    ctx.fill();
                    ctx.fillStyle = "#333";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(this.chatText, 0, 0);
                    ctx.restore();
                }

                ctx.rotate(this.angle);

                if (this.isDead) {
                    ctx.globalAlpha = 0.6;
                    ctx.filter = "grayscale(0.8)";
                }

                ctx.shadowColor = 'rgba(0,0,0,0.2)';
                ctx.shadowBlur = 10;

                // Body
                ctx.fillStyle = this.species.colorBody;
                ctx.beginPath();
                ctx.ellipse(0, 0, this.size, this.size * 0.6, 0, 0, Math.PI * 2);
                ctx.fill();

                // Eye
                if (this.isDead) {
                     ctx.strokeStyle = '#333';
                     ctx.lineWidth = 2;
                     ctx.beginPath();
                     ctx.moveTo(this.size*0.3, -this.size*0.3);
                     ctx.lineTo(this.size*0.5, -this.size*0.1);
                     ctx.moveTo(this.size*0.5, -this.size*0.3);
                     ctx.lineTo(this.size*0.3, -this.size*0.1);
                     ctx.stroke();
                } else {
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(this.size * 0.4, -this.size * 0.2, this.size * 0.25, 0, Math.PI*2);
                    ctx.fill();
                    ctx.fillStyle = '#222';
                    ctx.beginPath();
                    ctx.arc(this.size * 0.5, -this.size * 0.2, this.size * 0.1, 0, Math.PI*2);
                    ctx.fill();
                }

                // Tail
                ctx.fillStyle = this.species.colorFin;
                let tailWag = this.isDead ? 0 : Math.sin(this.tailAngle) * (this.size * 0.5);
                ctx.beginPath();
                ctx.moveTo(-this.size * 0.8, 0);
                if (this.species.finType === 'flowing') {
                    ctx.bezierCurveTo(-this.size * 1.5, tailWag, -this.size * 2.5, -this.size * 0.5 + tailWag, -this.size * 2.8, tailWag);
                    ctx.bezierCurveTo(-this.size * 2.5, this.size * 0.5 + tailWag, -this.size * 1.5, tailWag, -this.size * 0.8, 0);
                } else {
                    ctx.lineTo(-this.size * 1.8, -this.size * 0.6 + tailWag);
                    ctx.lineTo(-this.size * 1.8, this.size * 0.6 + tailWag);
                }
                ctx.fill();

                // Fin
                ctx.fillStyle = this.species.colorFin; 
                ctx.globalAlpha = this.isDead ? 0.4 : 0.8;
                ctx.beginPath();
                let finWag = this.isDead ? 0 : Math.cos(this.tailAngle) * 5;
                ctx.moveTo(0, this.size * 0.3);
                ctx.quadraticCurveTo(-this.size * 0.5, this.size + finWag, 0, this.size * 0.8);
                ctx.fill();

                // Top Fin
                if (this.species.finType !== 'simple') {
                    ctx.beginPath();
                    ctx.moveTo(0, -this.size * 0.5);
                    ctx.quadraticCurveTo(-this.size, -this.size * 1.2, this.size * 0.2, -this.size * 0.5);
                    ctx.fill();
                }

                if (isTalkMode && !this.isDead && this.size > 0) {
                    ctx.rotate(-this.angle);
                    ctx.fillStyle = "rgba(255, 255, 255, 0.95)";
                    ctx.font = "bold 14px 'Patrick Hand'";
                    ctx.textAlign = "center";
                    ctx.shadowColor = "rgba(0,0,0,0.8)";
                    ctx.shadowBlur = 3;
                    ctx.fillText(this.name, 0, this.size + 20);
                    ctx.shadowBlur = 0; 
                }

                ctx.restore();
            }
        }

        // --- Core Systems ---

        const rand = (min, max) => Math.random() * (max - min) + min;
        
        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            window.addEventListener('resize', resize);
            resize();

            canvas.addEventListener('mousedown', handleInput);
            canvas.addEventListener('touchstart', (e) => {
                handleInput(e.touches[0]);
            });

            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                mousePos.x = e.clientX - rect.left;
                mousePos.y = e.clientY - rect.top;
            });

            // Initial fish are "bought" (adults)
            fishes.push(new Fish(SPECIES[0], false));
            for(let i=0; i<20; i++) particles.push(new Bubble());

            initShop();
            loop();
            
            setInterval(() => {
                score += fishes.length;
                updateScore();
            }, 3000);
        }

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }

        function toggleTalkMode() {
            isTalkMode = !isTalkMode;
            const btn = document.getElementById('talkBtn');
            if (isTalkMode) {
                btn.classList.add('active');
                btn.innerText = "üêü Feed the Spirits";
                document.body.style.cursor = "help";
            } else {
                btn.classList.remove('active');
                btn.innerText = "‚ú® Talk to Spirits";
                document.body.style.cursor = "default";
            }
        }

        function toggleAutoFeed() {
            isAutoFeed = !isAutoFeed;
            const btn = document.getElementById('autoFeedBtn');
            
            if (isAutoFeed) {
                btn.classList.add('active');
                btn.innerText = "üçÇ Auto Feed: ON";
                
                autoFeedTimer = setInterval(() => {
                    particles.push(new Food(rand(50, width - 50), -10));
                }, 2000);
            } else {
                btn.classList.remove('active');
                btn.innerText = "üçÇ Auto Feed: OFF";
                clearInterval(autoFeedTimer);
            }
        }

        function showToast(msg) {
            const t = document.getElementById('toast');
            t.innerText = msg;
            t.style.opacity = 1;
            setTimeout(() => t.style.opacity = 0, 2000);
        }

        function handleInput(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (isTalkMode) {
                let clickedFish = null;
                // Use distSq for interaction check too
                for (let f of fishes) {
                    if (!f.isDead) {
                        let dSq = Vector.distSq(new Vector(x, y), f.pos);
                        if (dSq < (f.size + 20)**2) {
                            clickedFish = f;
                            break;
                        }
                    }
                }

                if (clickedFish) {
                    clickedFish.talk();
                } else {
                    ripples.push(new Ripple(x, y));
                }
            } else {
                particles.push(new Food(x, y));
                ripples.push(new Ripple(x, y));
            }
        }

        function addToGraveyard(fish) {
            const list = document.getElementById('graveyardList');
            const div = document.createElement('div');
            div.className = 'tombstone';
            
            const mins = ((Date.now() - fish.birthTime) / 60000).toFixed(1);
            const reason = fish.deathReason || "passed away";

            div.innerHTML = `
                ${fish.name} (${fish.species.name})
                <span>${reason} after ${mins} minutes</span>
            `;
            list.insertBefore(div, list.children[1]); 
        }

        function initShop() {
            const container = document.getElementById('shopContainer');
            container.innerHTML = '';
            
            SPECIES.forEach(s => {
                const el = document.createElement('div');
                el.className = 'fish-card';
                el.id = `shop-item-${s.id}`;
                
                // Canvas for icon
                const canvas = document.createElement('canvas');
                canvas.width = 60;
                canvas.height = 40;
                canvas.className = 'fish-preview-canvas';
                canvas.id = `preview-${s.id}`;
                
                el.appendChild(canvas);
                
                const nameEl = document.createElement('div');
                nameEl.className = 'fish-name';
                nameEl.innerText = s.name;
                el.appendChild(nameEl);
                
                const costEl = document.createElement('div');
                costEl.className = 'fish-cost';
                costEl.innerText = `${s.cost} Orbs`;
                el.appendChild(costEl);
                
                el.onclick = () => buyFish(s);
                container.appendChild(el);
            });
            
            // Render icons
            renderShopIcons();
            updateShopUI();
        }

        function renderShopIcons() {
            SPECIES.forEach(s => {
                const canvas = document.getElementById(`preview-${s.id}`);
                const pCtx = canvas.getContext('2d');
                
                // Create dummy fish (adult)
                const dummy = new Fish(s, false);
                dummy.pos.x = 30;
                dummy.pos.y = 20;
                dummy.size = Math.min(s.size, 15); // Limit size for icon
                dummy.angle = 0;
                
                pCtx.clearRect(0, 0, 60, 40);
                dummy.draw(pCtx);
            });
        }

        function buyFish(species) {
            if (score >= species.cost) {
                score -= species.cost;
                updateScore();
                showToast("Summoning Spirit...");
                
                // Pass false to indicate this is a bought adult
                const f = new Fish(species, false);
                f.pos.x = width / 2;
                f.pos.y = height / 2;
                fishes.push(f);
                
                ripples.push(new Ripple(width/2, height/2));
            }
        }

        function updateScore() {
            document.getElementById('scoreDisplay').innerText = Math.floor(score);
            updateShopUI();
        }

        function updateShopUI() {
            SPECIES.forEach(s => {
                const el = document.getElementById(`shop-item-${s.id}`);
                if (score >= s.cost) {
                    el.classList.remove('locked');
                    el.classList.add('affordable');
                } else {
                    el.classList.add('locked');
                    el.classList.remove('affordable');
                }
            });
        }

        function drawBackground() {
            let grad = ctx.createLinearGradient(0, 0, 0, height);
            grad.addColorStop(0, CONFIG.colors.waterTop);
            grad.addColorStop(1, CONFIG.colors.waterBottom);
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, width, height);

            ctx.save();
            ctx.globalCompositeOperation = 'overlay';
            ctx.fillStyle = CONFIG.colors.caustic;
            let time = Date.now() * 0.0005;
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                let x = (width * 0.2 * i) + Math.sin(time + i) * 50;
                ctx.moveTo(x - 100, height);
                ctx.lineTo(x + 300, 0);
                ctx.lineTo(x + 500, 0);
                ctx.lineTo(x + 300, height);
                ctx.fill();
            }
            ctx.restore();

            ctx.save();
            ctx.fillStyle = "rgba(255, 255, 255, 0.03)";
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(width, 0);
            ctx.lineTo(width * 0.8, height);
            ctx.lineTo(width * 0.2, height);
            ctx.fill();
            ctx.restore();
        }

        function loop() {
            requestAnimationFrame(loop);

            let now = Date.now();
            let dt = (now - lastTime) / 1000;
            lastTime = now;

            ctx.clearRect(0, 0, width, height);
            drawBackground();

            let foodItems = particles.filter(p => p instanceof Food);
            
            ripples.forEach((r, i) => {
                r.update();
                r.draw(ctx);
                if(r.opacity <= 0) ripples.splice(i, 1);
            });

            foodItems.forEach(f => {
                f.update();
                f.draw(ctx);
            });

            // Lists for post-processing removal
            let deadFish = [];
            let eatenFish = []; 

            fishes.forEach(fish => {
                let status = fish.update(foodItems, fishes); 
                fish.draw(ctx);
                
                if (status === 'gone') {
                    deadFish.push(fish);
                } else if (status === 'eaten') {
                    eatenFish.push(fish);
                    
                    // Spawning blood cloud particle effect
                    for(let i=0; i<30; i++) {
                        if(particles.length < 300) {
                            particles.push({
                                x: fish.pos.x, y: fish.pos.y,
                                vx: rand(-3,3), vy: rand(-3,3),
                                life: 1.0, color: '#E74C3C' // Blood red
                            });
                        }
                    }
                }
            });

            // Remove fish
            deadFish.forEach(fish => {
                const index = fishes.indexOf(fish);
                if (index > -1) {
                    addToGraveyard(fish);
                    fishes.splice(index, 1);
                }
            });
            
            eatenFish.forEach(fish => {
                const index = fishes.indexOf(fish);
                if (index > -1) {
                    addToGraveyard(fish); 
                    fishes.splice(index, 1);
                }
            });

            // Optimized Particle Loop (Backwards)
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                
                if (p instanceof Food) {
                    if (p.eaten) {
                        particles.splice(i, 1);
                    }
                    continue;
                }
                
                if (p instanceof Bubble) {
                    p.update();
                    p.draw(ctx);
                    continue;
                }

                // Generic particles (blood, sparks)
                if (p.life) {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= 0.05;
                    
                    if (p.life <= 0) {
                        particles.splice(i, 1);
                    } else {
                        ctx.fillStyle = p.color ? p.color : `rgba(255, 255, 255, ${p.life})`;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, 2, 0, Math.PI*2);
                        ctx.fill();
                    }
                }
            }
        }

        init();

    </script>
</body>
</html>
