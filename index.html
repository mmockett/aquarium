<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spirit Aquarium (Optimized)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Patrick+Hand&display=swap');

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #2b3a42;
            font-family: 'Patrick Hand', cursive;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-top {
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            pointer-events: auto;
        }

        .left-group, .right-group {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .score-container {
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(5px);
            padding: 10px 25px;
            border-radius: 50px;
            color: #fff;
            font-size: 24px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .help-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            font-family: 'Patrick Hand', cursive;
            font-size: 24px;
            color: #2b3a42;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s;
        }

        .help-btn:hover {
            transform: scale(1.1);
        }

        .button-group {
            display: flex;
            gap: 10px;
        }

        .mode-btn {
            background: rgba(255, 255, 255, 0.9);
            border: none;
            padding: 10px 20px;
            border-radius: 30px;
            font-family: 'Patrick Hand', cursive;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .mode-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }

        .mode-btn.active {
            background: #a4dddb;
            color: #16252B;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.1);
        }

        .currency-icon {
            width: 20px;
            height: 20px;
            background: radial-gradient(circle at 30% 30%, #fff, #a4dddb);
            border-radius: 50%;
            box-shadow: 0 0 10px #a4dddb;
        }

        .bottom-ui {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: auto;
            pointer-events: none;
        }

        .shop-container {
            pointer-events: auto;
            background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
            padding: 20px;
            display: flex;
            gap: 15px;
            overflow-x: auto;
            align-items: flex-end;
            padding-bottom: 30px;
            padding-right: 280px; 
            scrollbar-width: none;
        }
        
        .shop-container::-webkit-scrollbar {
            display: none;
        }

        .graveyard-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 220px;
            max-height: 200px; 
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
            border-radius: 12px;
            padding: 15px;
            color: #ddd;
            pointer-events: auto;
            overflow-y: auto;
            border: 1px solid rgba(255,255,255,0.1);
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .graveyard-container::-webkit-scrollbar {
            width: 6px;
        }
        .graveyard-container::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
        }
        .graveyard-container::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.3);
            border-radius: 3px;
        }

        .graveyard-title {
            font-size: 18px;
            color: #a4dddb;
            border-bottom: 1px solid rgba(255,255,255,0.2);
            padding-bottom: 5px;
            margin-bottom: 5px;
            position: sticky;
            top: 0;
            background: rgba(0,0,0,0.0);
            backdrop-filter: blur(0);
        }

        .tombstone {
            font-size: 14px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            padding-bottom: 4px;
            flex-shrink: 0; 
        }

        .tombstone span {
            display: block;
            font-size: 12px;
            color: #888;
        }

        .fish-card {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            padding: 10px;
            min-width: 100px;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s, filter 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            position: relative;
            opacity: 0.8;
            border: 2px solid transparent;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .fish-card:hover {
            transform: translateY(-10px);
            opacity: 1;
            z-index: 10;
        }

        .fish-card.locked {
            background: rgba(100, 100, 100, 0.5);
            cursor: not-allowed;
            filter: grayscale(1);
        }

        .fish-card.affordable {
            border-color: #88e1d5;
            box-shadow: 0 0 15px rgba(136, 225, 213, 0.5);
        }

        /* Predator Badge Style */
        .predator-badge {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #E74C3C;
            color: white;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            z-index: 20;
            cursor: help;
        }

        .fish-preview-canvas {
            margin-bottom: 5px;
        }

        .fish-name {
            font-size: 16px;
            color: #333;
            font-weight: bold;
        }

        .fish-cost {
            font-size: 14px;
            color: #666;
        }

        #toast {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .tutorial-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255,255,255,0.8);
            font-size: 24px;
            pointer-events: none;
            animation: fadeOut 5s forwards;
            animation-delay: 3s;
            text-align: center;
        }

        #idlePrompt {
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255,255,255,0.9);
            font-size: 24px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 1s;
            text-align: center;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            font-family: 'Patrick Hand', cursive;
        }

        /* Overlays */
        #helpOverlay, #restartOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(5px);
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            z-index: 100;
        }

        #helpOverlay.show, #restartOverlay.show {
            opacity: 1;
            pointer-events: auto;
        }

        .help-modal, .restart-modal {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            position: relative;
            text-align: center;
        }

        .help-modal h2, .restart-modal h2 {
            color: #2b3a42;
            margin-top: 0;
            border-bottom: 2px solid #a4dddb;
            padding-bottom: 10px;
        }

        .help-modal h3 {
            color: #E76F51;
            margin-bottom: 5px;
            text-align: left;
        }

        .help-modal p {
            color: #555;
            line-height: 1.5;
            margin-bottom: 15px;
            text-align: left;
        }

        .restart-modal p {
            color: #555;
            font-size: 18px;
            margin: 20px 0;
        }

        .restart-btn {
            background: #E76F51;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 30px;
            font-family: 'Patrick Hand', cursive;
            font-size: 20px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 10px rgba(231, 111, 81, 0.3);
        }

        .restart-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 15px rgba(231, 111, 81, 0.4);
        }

        .close-help {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 24px;
            cursor: pointer;
            color: #888;
        }

        .close-help:hover {
            color: #333;
        }

        @keyframes fadeOut {
            to { opacity: 0; }
        }

        /* --- UI Toggle Button --- */
        .ui-toggle-btn {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            font-size: 20px;
            cursor: pointer;
            pointer-events: auto;
            z-index: 1000;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
        }

        .ui-toggle-btn:hover {
            background: rgba(255, 255, 255, 0.4);
            transform: scale(1.1);
        }

        /* Hidden State: Fades out specific hideable elements */
        body.ui-hidden .hideable,
        body.ui-hidden .bottom-ui,
        body.ui-hidden .tutorial-text,
        body.ui-hidden #idlePrompt,
        body.ui-hidden #toast {
            opacity: 0 !important;
            transition: opacity 0.8s ease;
        }

        /* FIX: Explicitly disable pointer events on containers that are normally 'auto' */
        body.ui-hidden .shop-container,
        body.ui-hidden .graveyard-container,
        body.ui-hidden .hud-top,
        body.ui-hidden .hideable {
            pointer-events: none !important;
        }

        /* Toggle button becomes subtle when UI is hidden */
        body.ui-hidden .ui-toggle-btn {
            opacity: 0.3;
            background: transparent;
            border-color: transparent;
        }
        
        body.ui-hidden .ui-toggle-btn:hover {
            opacity: 1;
            background: rgba(255, 255, 255, 0.2);
        }

    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="hud-top">
            <!-- Added 'hideable' class for toggle logic -->
            <div class="left-group hideable">
                <div class="score-container">
                    <div class="currency-icon"></div>
                    <span id="scoreDisplay">0</span>
                </div>
                <button class="help-btn" onclick="toggleHelp()">?</button>
            </div>
            
            <!-- New Right Group to hold buttons + toggle aligner -->
            <div class="right-group">
                <div class="button-group hideable">
                    <button id="autoFeedBtn" class="mode-btn" onclick="toggleAutoFeed()">
                        üçÇ Auto Feed: OFF
                    </button>
                    <button id="talkBtn" class="mode-btn" onclick="toggleTalkMode()">
                        ‚ú® Talk to Spirits
                    </button>
                </div>
                <!-- Moved Toggle Button inside flex container for perfect alignment -->
                <button id="uiToggleBtn" class="ui-toggle-btn" onclick="toggleUI()" title="Toggle UI">üëÅÔ∏è</button>
            </div>
        </div>
        
        <div id="toast">Summoning...</div>
        <div class="tutorial-text">Click to feed the spirits...</div>
        <div id="idlePrompt">The spirits are waiting... click to offer food.</div>

        <div class="bottom-ui">
            <div class="shop-container" id="shopContainer"></div>
            <div class="graveyard-container" id="graveyardList">
                <div class="graveyard-title">Spirit Memories (0)</div>
            </div>
        </div>

        <div id="helpOverlay">
            <div class="help-modal">
                <span class="close-help" onclick="toggleHelp()">√ó</span>
                <h2>Aquarium Guide</h2>
                
                <h3>üçÇ Feeding & Growth</h3>
                <p>Click to drop food. Fish eat to grow larger and earn you Spirit Orbs. Keep them well-fed (Energy > 0) or they may starve!</p>
                
                <h3>‚ù§Ô∏è Reproduction</h3>
                <p>Two well-fed adult fish of the same species may fall in love and create offspring. Keep the population under 50 to allow new births.</p>
                
                <h3>ü¶à Predators & Prey</h3>
                <p>Some spirits hunt others! Predators will lock onto smaller prey. Prey that have eaten recently (within 20s) can sprint to escape.</p>

                <h3>‚ö†Ô∏è Territorial Tantrums</h3>
                <p>If two predators get too close, they will fight! While fighting (marked by üí¢), they are too distracted to hunt prey.</p>
                
                <h3>‚ú® Talk to Spirits</h3>
                <p>Toggle "Talk" mode to click on spirits and hear their thoughts. In this mode, they slow down for you.</p>
                
                <h3>üíÄ The Circle of Life</h3>
                <p>Spirits live for a random time (1-24 hours). When they pass, they join the Spirit Memories.</p>
            </div>
        </div>

        <div id="restartOverlay">
            <div class="restart-modal">
                <h2>The Waters are Still</h2>
                <p>All spirits have departed, and you lack the orbs to summon more.</p>
                <button class="restart-btn" onclick="restartGame()">Begin Anew</button>
            </div>
        </div>
    </div>

    <script>
        // --- Fallback Data (Ghibli Style) ---
        const FALLBACK_NAMES = [
            "Chihiro", "Haku", "Totoro", "Kiki", "Jiji", "Ponyo", "Sosuke", "Sophie", "Howl", "Calcifer", 
            "Markl", "Nausicaa", "Sheeta", "Pazu", "San", "Ashitaka", "Yubaba", "Kamaji", "Lin", "No-Face", 
            "Baron", "Muta", "Haru", "Seiji", "Shizuku", "Natori", "Nao", "Toto",
            "Arrietty", "Spiller", "Marnie", "Anna", "Umi", "Shun", "Pod", "Homily", "Sadako",
            "Yakul", "Moro", "Okami", "Nago", "Okkoto", "Gonza", "Toki", "Eboshi", "Jigo", "Kaya", "Hii-sama", "Kohroku",
            "Zeniba", "Boh", "Aogaeru", "Bandai-gaeru", "Chichiyaku", "Aniyaku",
            "Turnip", "Heen", "Lettie", "Honey", "Suliman",
            "Arren", "Therru", "Sparrowhawk", "Ged", "Tenar", "Tehanu", "Cob", "Hare",
            "Jiro", "Nahoko", "Caproni", "Castorp", "Honjo", "Kayo",
            "Fujimoto", "Granmamare", "Lisa", "Koichi", "Toki", "Yoshie", "Noriko", "Kumiko", "Karen",
            "Tombo", "Osono", "Fukuo", "Ursula", "Ket", "Maki", "Madame", "Barsa",
            "Dola", "Charles", "Louis", "Henri", "Motro", "Okami", "Muska", "Uncle Pom"
        ];

        const FALLBACK_PHRASES = {
            'curious and bubbly': [
                "Sparkles!", "Bloop bloop!", "Is that food?", "Yum yum!", "Friend?", "Swimming!", 
                "Happy bubbles!", "So shiny!", "Did you see that?", "Round and round!", "Tee hee!", 
                "Water is nice!", "Hello up there!", "Wiggle wiggle.", "Play with me!", "I found a bubble!"
            ],
            'playful, clicking, and mysterious': [
                "Click...", "Echoes...", "Hide and seek?", "Catch me!", "Spirits whisper...", 
                "Tee hee!", "Invisible...", "You can't see me.", "Secrets...", "The water remembers.", 
                "Pop!", "Do you know the way?", "Turning...", "Softly now.", "I am here... and there."
            ],
            'slow, wise, and sleepy': [
                "The river knows...", "Zzz...", "Currents shift...", "Patience...", "Drifting...", 
                "Ancient waters...", "Rest now.", "Time flows like water.", "Hrmmm...", "No rush.", 
                "The moss grows slow.", "Quiet thoughts.", "Deep breaths.", "Sleepy tides.", "A long journey."
            ],
            'majestic, ancient, and noble': [
                "Behold.", "The deep calls.", "Golden light.", "Respect the water.", "I watch over all.", 
                "Grace.", "Silence.", "The sky reflects here.", "Do not disturb the flow.", "I have seen ages.", 
                "Noble currents.", "Rise above.", "Tranquility.", "The spirits are watching.", "Pure waters."
            ],
            'silent, hungry, and eerie': [
                "...", "Ah... ah...", "Gold...", "Hungry...", "Feed me...", "Lonely...", 
                "Empty...", "Want...", "More...", "Darkness...", "Cold...", "Waiting...", 
                "Give...", "Shadow...", "Lost..."
            ],
            'energetic, starlike, and fast': [
                "Zoom!", "Twinkle!", "Shooting star!", "Catch me!", "Light!", "Speed!", 
                "Zap!", "Faster!", "Can't stop!", "Glowing!", "Look at me!", "Whoosh!", 
                "Bright!", "Starlight!", "Burning bright!"
            ],
            'aggressive, hunting, and sharp': [
                "Prey...", "Shadows...", "Snap!", "Watching...", "Hunger...", "Darkness...", 
                "Closer...", "Hunt.", "Sharp teeth.", "Silent stalker.", "Fear me.", "Blood in the water.", 
                "My domain.", "Trespasser.", "Got you."
            ],
            'massive, slow, and insatiable': [
                "Gulp.", "Ancient hunger.", "Floating...", "Everything is food.", "Slowly...", 
                "Grow...", "Endless...", "Mouth open.", "Drift to me.", "Heavy...", "Big water.", 
                "Swallow whole.", "Deep belly.", "River god.", "Mountain of flesh."
            ]
        };

        // --- Gemini API Integration ---
        const apiKey = ""; // Injected by environment

        async function callGemini(prompt) {
            if (!apiKey) return null; 

            const delays = [1000, 2000, 4000];
            
            for (let attempt = 0; attempt <= 2; attempt++) {
                try {
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: prompt }] }]
                        })
                    });
                    
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    
                    const data = await response.json();
                    return data.candidates?.[0]?.content?.parts?.[0]?.text?.trim();
                } catch (e) {
                    console.warn("Gemini API attempt failed, using fallback later.");
                    await new Promise(resolve => setTimeout(resolve, delays[attempt]));
                }
            }
            return null;
        }

        // --- Configuration & Assets ---
        const CONFIG = {
            colors: {
                waterTop: '#2F5A6E',
                waterBottom: '#16252B',
                ray: 'rgba(255, 255, 255, 0.03)',
                food: '#E8B67D',
                caustic: 'rgba(164, 221, 219, 0.05)'
            },
            physics: {
                friction: 0.96,
                turnSpeed: 0.08,
                foodGravity: 0.8
            }
        };

        const SPECIES = [
            {
                id: 'basic',
                name: 'River Spirit',
                cost: 100,
                colorBody: '#E86F51', 
                colorFin: '#F4A261',
                size: 15,
                speed: 2.5,
                finType: 'simple',
                personality: 'curious and bubbly'
            },
            {
                id: 'starbit',
                name: 'Star Bit Guppy',
                cost: 250,
                colorBody: '#FFD93D', 
                colorFin: '#FFF',
                size: 10,
                speed: 4.0,
                finType: 'simple',
                personality: 'energetic, starlike, and fast'
            },
            {
                id: 'kodama',
                name: 'Kodama Tetra',
                cost: 350,
                colorBody: '#F1FAEE', 
                colorFin: '#A8DADC',
                size: 12,
                speed: 3.5,
                finType: 'glow',
                personality: 'playful, clicking, and mysterious'
            },
            {
                id: 'forest',
                name: 'Mossy Carp',
                cost: 800,
                colorBody: '#457B9D', 
                colorFin: '#1D3557',
                size: 25,
                speed: 1.8,
                finType: 'flowing',
                personality: 'slow, wise, and sleepy'
            },
            {
                id: 'hunter',
                name: 'Shadow Hunter',
                cost: 1200,
                colorBody: '#2C3E50',
                colorFin: '#E74C3C',
                size: 30,
                speed: 3.8,
                finType: 'fancy',
                personality: 'aggressive, hunting, and sharp',
                isPredator: true
            },
            {
                id: 'sun',
                name: 'Sky Spirit',
                cost: 2000,
                colorBody: '#fff', 
                colorFin: '#48CAE4',
                size: 35,
                speed: 3.0,
                finType: 'flowing',
                personality: 'majestic, ancient, and noble'
            },
            {
                id: 'lord',
                name: 'River Lord',
                cost: 5000,
                colorBody: '#4A5568',
                colorFin: '#2D3748',
                size: 60,
                speed: 1.2,
                finType: 'flowing',
                personality: 'massive, slow, and insatiable',
                isPredator: true
            }
        ];

        // --- OPTIMIZATION: Spatial Hash Grid ---
        // Replaces the O(N^2) distance check with a specialized O(N) grid check
        class SpatialHash {
            constructor(cellSize) {
                this.cellSize = cellSize;
                this.grid = new Map();
            }

            getKey(x, y) {
                return `${Math.floor(x / this.cellSize)},${Math.floor(y / this.cellSize)}`;
            }

            clear() {
                this.grid.clear();
            }

            add(client) {
                const key = this.getKey(client.pos.x, client.pos.y);
                if (!this.grid.has(key)) {
                    this.grid.set(key, []);
                }
                this.grid.get(key).push(client);
            }

            getNearby(client) {
                const keys = [];
                const cx = Math.floor(client.pos.x / this.cellSize);
                const cy = Math.floor(client.pos.y / this.cellSize);

                // Check 3x3 grid around client
                for (let x = cx - 1; x <= cx + 1; x++) {
                    for (let y = cy - 1; y <= cy + 1; y++) {
                        keys.push(`${x},${y}`);
                    }
                }

                let results = [];
                for (let key of keys) {
                    if (this.grid.has(key)) {
                        results = results.concat(this.grid.get(key));
                    }
                }
                return results;
            }
        }


        // --- Game State ---
        let canvas, ctx;
        let width, height;
        let score = 0;
        let particles = [];
        let fishes = [];
        let ripples = [];
        let lastTime = 0;
        let isTalkMode = false;
        let isAutoFeed = false;
        let autoFeedTimer = null;
        let mousePos = { x: -9999, y: -9999 };
        let deadCount = 0;
        let idleTimer = null;
        
        // Init Grid with cell size 150 (roughly max visual interaction range)
        const spatialGrid = new SpatialHash(150);

        // --- Classes ---

        class Vector {
            constructor(x, y) { this.x = x; this.y = y; }
            add(v) { this.x += v.x; this.y += v.y; return this; }
            sub(v) { this.x -= v.x; this.y -= v.y; return this; }
            mult(n) { this.x *= n; this.y *= n; return this; }
            div(n) { if(n!==0) { this.x /= n; this.y /= n; } return this; }
            mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
            magSq() { return this.x * this.x + this.y * this.y; }
            normalize() {
                let m = this.mag();
                if (m !== 0) this.mult(1/m);
                return this;
            }
            limit(max) {
                if (this.magSq() > max * max) {
                    this.normalize();
                    this.mult(max);
                }
                return this;
            }
            static sub(v1, v2) { return new Vector(v1.x - v2.x, v1.y - v2.y); }
            static distSq(v1, v2) {
                let dx = v1.x - v2.x;
                let dy = v1.y - v2.y;
                return dx*dx + dy*dy;
            }
        }

        const distSq = (x1, y1, x2, y2) => (x2 - x1)**2 + (y2 - y1)**2;
        const dist = (x1, y1, x2, y2) => Math.sqrt(distSq(x1, y1, x2, y2));

        class Ripple {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 1;
                this.maxRadius = 60;
                this.opacity = 0.6;
                this.speed = 1.5;
            }
            update() {
                this.radius += this.speed;
                this.opacity -= 0.01;
            }
            draw(ctx) {
                if(this.opacity <= 0) return;
                ctx.beginPath();
                ctx.strokeStyle = `rgba(255, 255, 255, ${this.opacity})`;
                ctx.lineWidth = 2;
                ctx.ellipse(this.x, this.y, this.radius, this.radius * 0.6, 0, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        class Food {
            constructor(x, y) {
                this.pos = new Vector(x, y);
                this.vel = new Vector(0, 0);
                this.acc = new Vector(0, CONFIG.physics.foodGravity * 0.1);
                this.size = 4;
                this.eaten = false;
                
                this.wobbleSpeed = rand(0.002, 0.005);
                this.wobbleDist = rand(0.2, 0.6);
                this.timeOffset = rand(0, 1000);
            }
            update() {
                this.vel.add(this.acc);
                this.vel.mult(0.95); 
                this.pos.add(this.vel);
                
                this.pos.x += Math.sin(Date.now() * this.wobbleSpeed + this.timeOffset) * this.wobbleDist;
                
                if (this.pos.y > height) this.eaten = true; 
            }
            draw(ctx) {
                ctx.fillStyle = CONFIG.colors.food;
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class Bubble {
            constructor() {
                this.reset();
                this.y = rand(height, height + 200);
            }
            reset() {
                this.x = rand(0, width);
                this.y = height + 10;
                this.size = rand(1, 4);
                this.speed = rand(0.5, 2);
                this.wobble = rand(0, Math.PI * 2);
            }
            update() {
                this.y -= this.speed;
                this.x += Math.sin(Date.now() * 0.002 + this.wobble) * 0.5;
                if (this.y < -10) this.reset();
            }
            draw(ctx) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class Fish {
            constructor(type, isBorn = false) {
                this.species = type;
                this.name = "Spirit"; 
                this.pos = new Vector(rand(100, width - 100), rand(100, height - 100));
                this.vel = new Vector(rand(-1, 1), rand(-1, 1));
                this.acc = new Vector(0, 0);
                this.angle = Math.random() * Math.PI * 2;
                
                this.maxSpeed = type.speed;
                this.maxForce = 0.1; 
                this.size = type.size;
                
                this.birthTime = Date.now();
                
                // BALANCE CHANGE: Predators die much faster (10-30 mins) to prevent tank wipes
                // Normal fish live 1-24 hours
                if (this.species.isPredator) {
                    this.lifespan = rand(10 * 60 * 1000, 30 * 60 * 1000);
                } else {
                    this.lifespan = rand(60 * 60 * 1000, 24 * 60 * 60 * 1000); 
                }

                this.isDead = false;
                this.isEaten = false; 
                
                this.energy = 100; 
                this.maxEnergy = 100;
                this.lastAteTime = 0; 

                this.digestionSlowdown = 1.0; 
                
                // NEW: Hunting Cooldown (2-3 minutes)
                // Prevents chain-killing. Fish enters "Food Coma" after eating.
                this.huntingCooldown = this.species.isPredator ? rand(120 * 1000, 180 * 1000) : 0;

                this.tailAngle = 0;
                this.tailSpeed = 0.2;
                
                this.chatText = null;
                this.chatTimer = 0;
                this.isTalking = false;

                this.romanceTarget = null; 
                this.huntingTarget = null;
                this.tantrumTarget = null; // NEW: Track rival predator

                // Offset Logic update to avoid every fish computing complex AI on same frame
                this.aiOffset = Math.floor(Math.random() * 3);

                // MATURITY LOGIC
                if (!isBorn) {
                    this.birthTime -= 120 * 1000;
                    this.lastReproductionTime = 0; 
                } else {
                    this.lastReproductionTime = Date.now(); 
                }

                this.generateName();
            }

            async generateName() {
                const prompt = `Generate a single, short, whimsical, Studio Ghibli-style name for a water spirit that looks like a ${this.species.name}. It should be unique and sound magical. Return ONLY the name, no other text.`;
                const newName = await callGemini(prompt);
                if (newName) this.name = newName;
                else this.name = FALLBACK_NAMES[Math.floor(Math.random() * FALLBACK_NAMES.length)];
            }

            async talk() {
                if (this.isTalking || this.isDead) return;
                this.isTalking = true;
                this.chatText = "...";
                const prompt = `Roleplay as a ${this.species.name} named ${this.name} in a magical Ghibli aquarium. Your personality is ${this.species.personality}. A human just waved at you. Respond with one very short, poetic, funny, or mystical sentence (max 10 words).`;
                const response = await callGemini(prompt);
                
                if (response) this.chatText = response;
                else {
                    const phrases = FALLBACK_PHRASES[this.species.personality] || ["Bloop?", "Hello...", "Splosh."];
                    this.chatText = phrases[Math.floor(Math.random() * phrases.length)];
                }
                this.chatTimer = 300;
                this.isTalking = false;
            }

            reproduce(mate) {
                const numOffspring = Math.floor(rand(1, 4)); 
                const spawnPos = new Vector((this.pos.x + mate.pos.x) / 2, (this.pos.y + mate.pos.y) / 2);
                
                showToast(`New Spirits! ${this.name} and ${mate.name} welcome ${numOffspring} babies.`);

                for (let i = 0; i < numOffspring; i++) {
                    const child = new Fish(this.species, true);
                    child.pos = new Vector(spawnPos.x + rand(-5,5), spawnPos.y + rand(-5,5)); 
                    child.size = this.species.size * 0.2; 
                    child.maxSpeed *= 1.5; 
                    child.lastReproductionTime = Date.now() + rand(5 * 60 * 1000, 10 * 60 * 1000);
                    fishes.push(child);
                    
                    for(let j=0; j<8; j++) {
                        if(particles.length < 200) {
                            particles.push({
                                x: spawnPos.x, y: spawnPos.y,
                                vx: rand(-2,2), vy: rand(-2,2),
                                life: 1.0, color: '#A4DDBB' 
                            });
                        }
                    }
                }

                const cooldown = rand(5 * 60 * 1000, 10 * 60 * 1000);
                this.lastReproductionTime = Date.now() + cooldown;
                mate.lastReproductionTime = Date.now() + cooldown;
                
                this.romanceTarget = null;
                mate.romanceTarget = null;
            }

            computeBehaviors(allFish) {
                let sep = new Vector(0, 0);
                let ali = new Vector(0, 0);
                let coh = new Vector(0, 0);
                let sepCount = 0, aliCount = 0, cohCount = 0;
                
                const desiredSeparationSq = (40 + this.size)**2;
                const neighborDistSq = 100**2;
                
                let closestPrey = null;
                let closestPreyDistSq = Infinity;
                const huntRangeSq = 250**2;
                
                let fleeVector = new Vector(0, 0);
                const fleeRangeSq = 150**2;
                
                // NEW: Logic for "Tantrums"
                let nearestRival = null;
                let nearestRivalDistSq = Infinity;
                const tantrumRangeSq = 200**2;

                const amPredator = this.species.isPredator;
                const amPrey = !amPredator;

                // OPTIMIZATION: Use spatial grid neighbors instead of allFish
                const nearbyFish = spatialGrid.getNearby(this);

                for (let other of nearbyFish) {
                    if (other === this || other.isDead) continue;
                    
                    let dSq = Vector.distSq(this.pos, other.pos);

                    if (dSq < neighborDistSq) {
                        if (dSq < desiredSeparationSq) {
                            let diff = Vector.sub(this.pos, other.pos);
                            diff.normalize();
                            // Weight separation by inverse distance
                            diff.div(Math.sqrt(dSq) || 0.1); 
                            sep.add(diff);
                            sepCount++;
                        }
                        
                        if (other.species.id === this.species.id) {
                             let alignVel = new Vector(other.vel.x, other.vel.y);
                             ali.add(alignVel);
                             aliCount++;
                             
                             let cohPos = new Vector(other.pos.x, other.pos.y);
                             coh.add(cohPos);
                             cohCount++;
                        }
                    }
                    
                    if (amPredator) {
                        // NEW: Hunting Cooldown Check
                        // Only hunt if enough time has passed since last meal
                        const isHungry = (Date.now() - this.lastAteTime) > this.huntingCooldown;

                        if (isHungry) {
                            // If other is predator, check for TANTRUM logic
                            if (other.species.isPredator) {
                                if (dSq < tantrumRangeSq && dSq < nearestRivalDistSq) {
                                    nearestRival = other;
                                    nearestRivalDistSq = dSq;
                                }
                            } 
                            // Normal Prey Logic
                            else if (other.size < this.size * 0.6) {
                                if (dSq < (this.size * 0.8)**2) {
                                    if (dSq < closestPreyDistSq && dSq < huntRangeSq) {
                                        closestPreyDistSq = dSq;
                                        closestPrey = other;
                                    }
                                } else if (dSq < huntRangeSq && dSq < closestPreyDistSq) {
                                    closestPreyDistSq = dSq;
                                    closestPrey = other;
                                }
                            }
                        } else {
                            // If not hungry, we might still check for rivals (tantrums), 
                            // but for now let's say a full predator is too lazy to fight too.
                            // (Optional: Move Tantrum check outside isHungry if you want fat predators to still fight)
                        }
                    }
                    
                    if (amPrey && other.species.isPredator) {
                        if (dSq < fleeRangeSq) {
                            let diff = Vector.sub(this.pos, other.pos);
                            diff.normalize();
                            fleeVector.add(diff);
                        }
                    }
                }

                // TANTRUM LOGIC: Overrides hunger if a rival is near
                if (nearestRival) {
                     this.tantrumTarget = nearestRival;
                     // Circle the rival (Perpendicular vector)
                     let toRival = Vector.sub(nearestRival.pos, this.pos);
                     toRival.normalize();
                     let tangent = new Vector(-toRival.y, toRival.x); // 90 deg rotation
                     tangent.mult(this.maxSpeed * 1.5);
                     
                     let steer = Vector.sub(tangent, this.vel);
                     steer.limit(this.maxForce * 2);
                     this.acc.add(steer);

                     // REMOVED: Frustration emote for cleaner aesthetic
                     // if (Math.random() < 0.05 && !this.chatText) {
                     //    this.chatText = "üí¢";
                     //    this.chatTimer = 60;
                     // }

                     // Clear hunting target so we don't chase food/prey
                     this.huntingTarget = null;
                } else {
                     this.tantrumTarget = null;
                     
                     // Normal behaviors
                     if (sepCount > 0) {
                        sep.div(sepCount); sep.normalize(); sep.mult(this.maxSpeed); sep.sub(this.vel); sep.limit(this.maxForce * 2.0);
                        this.acc.add(sep.mult(1.5));
                    }
                    if (aliCount > 0) {
                        ali.div(aliCount); ali.normalize(); ali.mult(this.maxSpeed); ali.sub(this.vel); ali.limit(this.maxForce);
                        this.acc.add(ali.mult(1.0));
                    }
                    if (cohCount > 0) {
                        coh.div(cohCount);
                        let desired = Vector.sub(coh, this.pos);
                        desired.normalize(); desired.mult(this.maxSpeed);
                        let steer = Vector.sub(desired, this.vel); steer.limit(this.maxForce);
                        this.acc.add(steer.mult(1.0));
                    }

                    if (amPredator && closestPrey) {
                         this.huntingTarget = closestPrey; 
                         let desired = Vector.sub(closestPrey.pos, this.pos);
                         desired.normalize();
                         desired.mult(this.maxSpeed * 1.2);
                         let steer = Vector.sub(desired, this.vel);
                         steer.limit(this.maxForce * 1.5);
                         this.acc.add(steer);
                    }
                }

                if (amPrey && (fleeVector.x !== 0 || fleeVector.y !== 0)) {
                    if (Date.now() - this.lastAteTime < 20000) {
                        fleeVector.normalize();
                        fleeVector.mult(this.maxSpeed * 2.0); 
                        let steer = Vector.sub(fleeVector, this.vel);
                        steer.limit(this.maxForce * 3.0);
                        this.acc.add(steer);
                        
                        if (Math.random() < 0.2 && particles.length < 200) {
                             particles.push({
                                x: this.pos.x, y: this.pos.y,
                                vx: rand(-1,1), vy: rand(-1,1),
                                life: 0.5, color: '#fff'
                             });
                        }
                    }
                }
            }

            update(foodList, allFish, frameCount) {
                if (!this.isDead) {
                    this.energy -= 0.006;
                    if (this.digestionSlowdown < 1.0) this.digestionSlowdown += 0.002;

                    // OPTIMIZATION: Check logic less frequently
                    if (frameCount % 60 === 0) {
                        // BALANCE CHANGE: Predators reproduce significantly less often
                        let mateChance = 0.02; // Base chance for normal fish
                        if (this.species.isPredator) mateChance = 0.002; // 10x less likely for predators

                        if (Math.random() < mateChance && fishes.length <= 50) {
                             const maturityAge = 60 * 1000;
                             const minCooldown = 5 * 60 * 1000;
                             
                             if (!this.romanceTarget && 
                                 Date.now() - this.birthTime > maturityAge &&
                                 Date.now() - this.lastReproductionTime > minCooldown && 
                                 this.energy >= 80) {
                                 
                                 // Romance check can still use allFish but only happens rarely
                                 let potentialMate = allFish.find(other => 
                                    other !== this && 
                                    other.species.id === this.species.id && 
                                    other.energy >= 80 && 
                                    Date.now() - other.birthTime > maturityAge && 
                                    Date.now() - other.lastReproductionTime > minCooldown &&
                                    distSq(this.pos.x, this.pos.y, other.pos.x, other.pos.y) < 200**2 
                                 );
                                 if (potentialMate) this.romanceTarget = potentialMate;
                             }
                        }
                    }

                    if (this.romanceTarget) {
                         if (this.romanceTarget.isDead || this.energy < 80 || Vector.distSq(this.pos, this.romanceTarget.pos) > 300**2) {
                             this.romanceTarget = null;
                         }
                    }

                    if (Date.now() - this.birthTime > this.lifespan || this.energy <= 0) {
                        this.isDead = true;
                        this.deathReason = this.energy <= 0 ? "Starved" : "Old Age";
                    }
                    // Reduced illness chance
                    if (Math.random() < 0.0000001) {
                        this.isDead = true;
                        this.deathReason = "Sudden Illness";
                    }
                }

                // Predation Logic
                // NEW: If Fighting/Tantruming, DO NOT hunt.
                if (this.species.isPredator && this.huntingTarget && !this.tantrumTarget) {
                    if (this.huntingTarget.isDead || Vector.distSq(this.pos, this.huntingTarget.pos) > 400**2) {
                        this.huntingTarget = null;
                    } else if (Vector.distSq(this.pos, this.huntingTarget.pos) < (this.size * 0.8)**2) {
                        this.huntingTarget.isDead = true;
                        this.huntingTarget.deathReason = `Eaten by ${this.name}`;
                        this.huntingTarget.isEaten = true;
                        this.feed();
                        this.huntingTarget = null;
                    }
                } else if (this.tantrumTarget) {
                    // Clear hunting target if we started fighting
                    this.huntingTarget = null;
                }

                if (this.isDead) {
                    if (this.isEaten) return 'eaten'; 
                    this.vel.x *= 0.9; 
                    this.vel.y = -1.5; 
                    let targetAngle = Math.PI;
                    this.angle += (targetAngle - this.angle) * 0.02;
                    this.pos.add(this.vel);
                    if (this.pos.y < -50) return 'gone';
                    return 'alive';
                }

                if (this.chatTimer > 0 && !this.isTalking) {
                    this.chatTimer--;
                    if (this.chatTimer <= 0) this.chatText = null;
                }

                // Food Seeking (Only if not fighting)
                let target = null;
                let closestDistSq = Infinity;
                let closestFood = null;
                let searchRadSq = 300**2;

                if (!this.tantrumTarget) {
                    // Check food every frame is okay if food count is low, 
                    // but optimizing closest search could be done via grid too if needed.
                    for (let f of foodList) {
                        if (!f.eaten) {
                            let dSq = Vector.distSq(this.pos, f.pos);
                            if (dSq < searchRadSq && dSq < closestDistSq) {
                                closestDistSq = dSq;
                                closestFood = f;
                            }
                        }
                    }
                }

                if (closestFood) {
                    target = closestFood.pos;
                    let eatDist = this.size + 5;
                    if (closestDistSq < eatDist*eatDist) {
                        closestFood.eaten = true;
                        this.feed();
                    }
                }

                // Movement & Steering
                if (target) {
                    this.seek(target);
                } else if (this.romanceTarget) {
                    this.seek(this.romanceTarget.pos);
                    if (distSq(this.pos.x, this.pos.y, this.romanceTarget.pos.x, this.romanceTarget.pos.y) < (this.size + this.romanceTarget.size)**2) {
                         this.reproduce(this.romanceTarget);
                    }
                } else {
                    // OPTIMIZATION: Stagger AI updates
                    // Only compute expensive flocking neighbors every 3 frames
                    if (frameCount % 3 === this.aiOffset) {
                        this.computeBehaviors(allFish);
                        this.wander(); 
                        this.boundaries();
                    }
                    // Acc is preserved between frames so force continues to apply
                }

                this.vel.add(this.acc);
                
                let dToMouseSq = Vector.distSq(this.pos, mousePos);
                let speedMod = 1;
                
                if (isTalkMode && dToMouseSq < 150**2) {
                    speedMod = 0.3;
                }

                let energyFactor = Math.max(0.2, this.energy / this.maxEnergy);
                speedMod *= energyFactor;
                speedMod *= this.digestionSlowdown;

                this.vel.limit(this.maxSpeed * (target ? 1.5 : 1) * speedMod);
                this.pos.add(this.vel);
                
                // Reset acceleration each frame to prevent buildup
                this.acc.mult(0); 

                if (this.pos.x < this.size) { this.pos.x = this.size; this.vel.x *= -0.8; }
                if (this.pos.x > width - this.size) { this.pos.x = width - this.size; this.vel.x *= -0.8; }
                if (this.pos.y < this.size) { this.pos.y = this.size; this.vel.y *= -0.8; }
                if (this.pos.y > height - this.size) { this.pos.y = height - this.size; this.vel.y *= -0.8; }
                
                let desiredAngle = Math.atan2(this.vel.y, this.vel.x);
                let diff = desiredAngle - this.angle;
                while (diff < -Math.PI) diff += Math.PI * 2;
                while (diff > Math.PI) diff -= Math.PI * 2;
                this.angle += diff * CONFIG.physics.turnSpeed;

                let speedPct = this.vel.mag() / (this.maxSpeed || 1);
                this.tailSpeed = 0.1 + (speedPct * 0.3);
                this.tailAngle += this.tailSpeed;

                return 'alive';
            }

            seek(target) {
                let desired = new Vector(target.x - this.pos.x, target.y - this.pos.y);
                desired.normalize();
                desired.mult(this.maxSpeed);
                let steer = Vector.sub(desired, this.vel);
                steer.limit(this.maxForce);
                this.acc.add(steer);
            }

            wander() {
                let wanderR = 50;
                let wanderD = 100;
                let circlePos = new Vector(this.vel.x, this.vel.y);
                circlePos.normalize();
                circlePos.mult(wanderD);
                circlePos.add(this.pos);
                let t = Date.now() * 0.001 + this.pos.x; 
                let h = Math.sin(t) * wanderR;
                let target = new Vector(circlePos.x + Math.cos(t)*20, circlePos.y + h);
                this.seek(target);
            }

            boundaries() {
                let margin = 100;
                let desired = null;
                if (this.pos.x < margin) desired = new Vector(this.maxSpeed, this.vel.y);
                else if (this.pos.x > width - margin) desired = new Vector(-this.maxSpeed, this.vel.y);
                if (this.pos.y < margin) desired = new Vector(this.vel.x, this.maxSpeed);
                else if (this.pos.y > height - margin) desired = new Vector(this.vel.x, -this.maxSpeed);
                if (desired) {
                    desired.normalize();
                    desired.mult(this.maxSpeed);
                    let steer = Vector.sub(desired, this.vel);
                    steer.limit(this.maxForce * 2);
                    this.acc.add(steer);
                }
            }

            feed() {
                if (this.isDead) return;
                score += 15;
                updateScore();
                this.energy = Math.min(this.maxEnergy, this.energy + 30);
                this.digestionSlowdown = 0.5; 
                this.lastAteTime = Date.now(); 

                const maxSize = this.species.size * 3.0; 
                if (this.size < maxSize) {
                    this.size += 0.8; 
                    this.maxSpeed = Math.max(this.species.speed * 0.5, this.maxSpeed - 0.02);
                }

                for(let i=0; i<5; i++) {
                    if (particles.length < 200) {
                        particles.push({
                            x: this.pos.x, y: this.pos.y,
                            vx: rand(-1,1), vy: rand(-1,1),
                            life: 1.0, color: '#fff'
                        });
                    }
                }
            }

            draw(ctx) {
                if (this.isDead && this.isEaten) return;

                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);

                if (this.chatText && !this.isDead && this.size > 0) {
                    ctx.save();
                    ctx.translate(0, -this.size * 2 - 20);
                    ctx.font = "16px 'Patrick Hand'";
                    let metrics = ctx.measureText(this.chatText);
                    let w = metrics.width + 20;
                    let h = 30;
                    ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
                    ctx.beginPath();
                    ctx.roundRect(-w/2, -h/2, w, h, 10);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(-5, h/2);
                    ctx.lineTo(5, h/2);
                    ctx.lineTo(0, h/2 + 6);
                    ctx.fill();
                    ctx.fillStyle = "#333";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(this.chatText, 0, 0);
                    ctx.restore();
                }

                ctx.rotate(this.angle);

                // OPTIMIZATION: Removed ctx.filter for dead fish.
                // Instead, we just draw with different colors manually if dead.
                // This saves massive GPU overhead.

                // OPTIMIZATION: Removed shadowBlur. 
                // Shadows on moving canvas entities are the #1 performance killer.
                // ctx.shadowColor = 'rgba(0,0,0,0.2)';
                // ctx.shadowBlur = 10;

                let bodyColor = this.species.colorBody;
                let finColor = this.species.colorFin;

                if (this.isDead) {
                    ctx.globalAlpha = 0.6;
                    bodyColor = '#555'; // Manual grayscale
                    finColor = '#333';
                }

                ctx.fillStyle = bodyColor;
                ctx.beginPath();
                ctx.ellipse(0, 0, this.size, this.size * 0.6, 0, 0, Math.PI * 2);
                ctx.fill();

                if (this.isDead) {
                     ctx.strokeStyle = '#333';
                     ctx.lineWidth = 2;
                     ctx.beginPath();
                     ctx.moveTo(this.size*0.3, -this.size*0.3);
                     ctx.lineTo(this.size*0.5, -this.size*0.1);
                     ctx.moveTo(this.size*0.5, -this.size*0.3);
                     ctx.lineTo(this.size*0.3, -this.size*0.1);
                     ctx.stroke();
                } else {
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(this.size * 0.4, -this.size * 0.2, this.size * 0.25, 0, Math.PI*2);
                    ctx.fill();
                    ctx.fillStyle = '#222';
                    ctx.beginPath();
                    ctx.arc(this.size * 0.5, -this.size * 0.2, this.size * 0.1, 0, Math.PI*2);
                    ctx.fill();
                }

                ctx.fillStyle = finColor;
                let tailWag = this.isDead ? 0 : Math.sin(this.tailAngle) * (this.size * 0.5);
                ctx.beginPath();
                ctx.moveTo(-this.size * 0.8, 0);
                if (this.species.finType === 'flowing') {
                    ctx.bezierCurveTo(-this.size * 1.5, tailWag, -this.size * 2.5, -this.size * 0.5 + tailWag, -this.size * 2.8, tailWag);
                    ctx.bezierCurveTo(-this.size * 2.5, this.size * 0.5 + tailWag, -this.size * 1.5, tailWag, -this.size * 0.8, 0);
                } else {
                    ctx.lineTo(-this.size * 1.8, -this.size * 0.6 + tailWag);
                    ctx.lineTo(-this.size * 1.8, this.size * 0.6 + tailWag);
                }
                ctx.fill();

                ctx.fillStyle = finColor; 
                ctx.globalAlpha = this.isDead ? 0.4 : 0.8;
                ctx.beginPath();
                let finWag = this.isDead ? 0 : Math.cos(this.tailAngle) * 5;
                ctx.moveTo(0, this.size * 0.3);
                ctx.quadraticCurveTo(-this.size * 0.5, this.size + finWag, 0, this.size * 0.8);
                ctx.fill();

                if (this.species.finType !== 'simple') {
                    ctx.beginPath();
                    ctx.moveTo(0, -this.size * 0.5);
                    ctx.quadraticCurveTo(-this.size, -this.size * 1.2, this.size * 0.2, -this.size * 0.5);
                    ctx.fill();
                }

                if (isTalkMode && !this.isDead && this.size > 0) {
                    ctx.rotate(-this.angle);
                    ctx.fillStyle = "rgba(255, 255, 255, 0.95)";
                    ctx.font = "bold 14px 'Patrick Hand'";
                    ctx.textAlign = "center";
                    // Simple text shadow is cheaper than blur
                    ctx.fillStyle = "rgba(0,0,0,0.5)";
                    ctx.fillText(this.name, 1, this.size + 21);
                    ctx.fillStyle = "white";
                    ctx.fillText(this.name, 0, this.size + 20);
                }

                ctx.restore();
            }
        }

        // --- Core Systems ---

        const rand = (min, max) => Math.random() * (max - min) + min;
        
        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            window.addEventListener('resize', resize);
            resize();

            canvas.addEventListener('mousedown', handleInput);
            canvas.addEventListener('touchstart', (e) => {
                handleInput(e.touches[0]);
            });

            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                mousePos.x = e.clientX - rect.left;
                mousePos.y = e.clientY - rect.top;
            });

            // Initial fish are "bought" (adults)
            fishes.push(new Fish(SPECIES[0], false));
            for(let i=0; i<20; i++) particles.push(new Bubble());

            initShop();
            loop();
            
            setInterval(() => {
                score += fishes.length;
                updateScore();
            }, 3000);

            // Start idle timer
            idleTimer = setTimeout(() => {
                const el = document.getElementById('idlePrompt');
                if(el) el.style.opacity = 1;
            }, 60000); // 60 seconds
        }

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }

        // --- NEW: Toggle UI Function ---
        function toggleUI() {
            document.body.classList.toggle('ui-hidden');
        }

        function toggleTalkMode() {
            isTalkMode = !isTalkMode;
            const btn = document.getElementById('talkBtn');
            if (isTalkMode) {
                btn.classList.add('active');
                btn.innerText = "üêü Feed the Spirits";
                document.body.style.cursor = "help";
            } else {
                btn.classList.remove('active');
                btn.innerText = "‚ú® Talk to Spirits";
                document.body.style.cursor = "default";
            }
        }

        function toggleAutoFeed() {
            isAutoFeed = !isAutoFeed;
            const btn = document.getElementById('autoFeedBtn');
            
            if (isAutoFeed) {
                btn.classList.add('active');
                btn.innerText = "üçÇ Auto Feed: ON";
                
                autoFeedTimer = setInterval(() => {
                    // FIX: Check particle limit to prevent memory issues
                    if (particles.length < 200) {
                        particles.push(new Food(rand(50, width - 50), -10));
                    }
                }, 2000);
            } else {
                btn.classList.remove('active');
                btn.innerText = "üçÇ Auto Feed: OFF";
                clearInterval(autoFeedTimer);
            }
        }

        function toggleHelp() {
            const overlay = document.getElementById('helpOverlay');
            overlay.classList.toggle('show');
        }

        function showToast(msg) {
            const t = document.getElementById('toast');
            t.innerText = msg;
            t.style.opacity = 1;
            setTimeout(() => t.style.opacity = 0, 2000);
        }

        function handleInput(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Clear idle timer on first interaction
            if (idleTimer) {
                clearTimeout(idleTimer);
                idleTimer = null;
                const el = document.getElementById('idlePrompt');
                if(el) el.style.opacity = 0;
            }

            if (isTalkMode) {
                let clickedFish = null;
                for (let f of fishes) {
                    if (!f.isDead) {
                        let dSq = Vector.distSq(new Vector(x, y), f.pos);
                        if (dSq < (f.size + 20)**2) {
                            clickedFish = f;
                            break;
                        }
                    }
                }

                if (clickedFish) {
                    clickedFish.talk();
                } else {
                    ripples.push(new Ripple(x, y));
                }
            } else {
                particles.push(new Food(x, y));
                ripples.push(new Ripple(x, y));
            }
        }

        function addToGraveyard(fish) {
            const list = document.getElementById('graveyardList');
            const div = document.createElement('div');
            div.className = 'tombstone';
            
            const mins = ((Date.now() - fish.birthTime) / 60000).toFixed(1);
            const reason = fish.deathReason || "passed away";

            div.innerHTML = `
                ${fish.name} (${fish.species.name})
                <span>${reason} after ${mins} minutes</span>
            `;
            list.insertBefore(div, list.children[1]); 
            
            // FIX: Cap Graveyard size to prevent DOM lag
            if (list.children.length > 31) {
                list.removeChild(list.lastChild);
            }
            
            deadCount++;
            document.querySelector('.graveyard-title').innerText = `Spirit Memories (${deadCount})`;
        }

        function initShop() {
            const container = document.getElementById('shopContainer');
            container.innerHTML = '';
            
            SPECIES.forEach(s => {
                const el = document.createElement('div');
                el.className = 'fish-card';
                el.id = `shop-item-${s.id}`;
                
                // NEW: Predator Badge
                if (s.isPredator) {
                    const badge = document.createElement('div');
                    badge.className = 'predator-badge';
                    badge.innerHTML = '‚ö†Ô∏è'; 
                    badge.title = 'Aggressive Predator';
                    el.appendChild(badge);
                }

                const canvas = document.createElement('canvas');
                canvas.width = 60;
                canvas.height = 40;
                canvas.className = 'fish-preview-canvas';
                canvas.id = `preview-${s.id}`;
                
                el.appendChild(canvas);
                
                const nameEl = document.createElement('div');
                nameEl.className = 'fish-name';
                nameEl.innerText = s.name;
                el.appendChild(nameEl);
                
                const costEl = document.createElement('div');
                costEl.className = 'fish-cost';
                costEl.innerText = `${s.cost} Orbs`;
                el.appendChild(costEl);
                
                el.onclick = () => buyFish(s);
                container.appendChild(el);
            });
            
            renderShopIcons();
            updateShopUI();
        }

        function renderShopIcons() {
            SPECIES.forEach(s => {
                const canvas = document.getElementById(`preview-${s.id}`);
                const pCtx = canvas.getContext('2d');
                
                const dummy = new Fish(s, false);
                dummy.pos.x = 30;
                dummy.pos.y = 20;
                dummy.size = Math.min(s.size, 15); 
                dummy.angle = 0;
                
                pCtx.clearRect(0, 0, 60, 40);
                dummy.draw(pCtx);
            });
        }

        function buyFish(species) {
            if (score >= species.cost) {
                score -= species.cost;
                updateScore();
                showToast("Summoning Spirit...");
                
                const f = new Fish(species, false);
                f.pos.x = width / 2;
                f.pos.y = height / 2;
                fishes.push(f);
                
                ripples.push(new Ripple(width/2, height/2));
            }
        }

        function updateScore() {
            document.getElementById('scoreDisplay').innerText = Math.floor(score);
            updateShopUI();
        }

        function updateShopUI() {
            SPECIES.forEach(s => {
                const el = document.getElementById(`shop-item-${s.id}`);
                if (score >= s.cost) {
                    el.classList.remove('locked');
                    el.classList.add('affordable');
                } else {
                    el.classList.add('locked');
                    el.classList.remove('affordable');
                }
            });
        }

        function checkGameOver() {
            if (fishes.length === 0 && score < 100) {
                document.getElementById('restartOverlay').classList.add('show');
            }
        }

        function restartGame() {
            score = 0;
            fishes = [];
            particles = [];
            ripples = [];
            deadCount = 0;
            
            document.getElementById('scoreDisplay').innerText = '0';
            document.querySelector('.graveyard-title').innerText = 'Spirit Memories (0)';
            
            const list = document.getElementById('graveyardList');
            while (list.children.length > 1) {
                list.removeChild(list.lastChild);
            }
            
            fishes.push(new Fish(SPECIES[0], false));
            
            document.getElementById('restartOverlay').classList.remove('show');
            
            updateShopUI();
        }

        function drawBackground() {
            let grad = ctx.createLinearGradient(0, 0, 0, height);
            grad.addColorStop(0, CONFIG.colors.waterTop);
            grad.addColorStop(1, CONFIG.colors.waterBottom);
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, width, height);

            ctx.save();
            ctx.globalCompositeOperation = 'overlay';
            ctx.fillStyle = CONFIG.colors.caustic;
            let time = Date.now() * 0.0005;
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                let x = (width * 0.2 * i) + Math.sin(time + i) * 50;
                ctx.moveTo(x - 100, height);
                ctx.lineTo(x + 300, 0);
                ctx.lineTo(x + 500, 0);
                ctx.lineTo(x + 300, height);
                ctx.fill();
            }
            ctx.restore();

            ctx.save();
            ctx.fillStyle = "rgba(255, 255, 255, 0.03)";
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(width, 0);
            ctx.lineTo(width * 0.8, height);
            ctx.lineTo(width * 0.2, height);
            ctx.fill();
            ctx.restore();
        }

        let frameCount = 0;

        function loop() {
            requestAnimationFrame(loop);
            frameCount++;

            let now = Date.now();
            let dt = (now - lastTime) / 1000;
            lastTime = now;

            // OPTIMIZATION: Clear grid once per frame
            spatialGrid.clear();
            for(let f of fishes) {
                if(!f.isDead) spatialGrid.add(f);
            }

            ctx.clearRect(0, 0, width, height);
            drawBackground();

            let foodItems = particles.filter(p => p instanceof Food);
            
            // OPTIMIZATION: Reverse loops for simpler removal logic
            for (let i = ripples.length - 1; i >= 0; i--) {
                let r = ripples[i];
                r.update();
                r.draw(ctx);
                if(r.opacity <= 0) ripples.splice(i, 1);
            }

            foodItems.forEach(f => {
                f.update();
                f.draw(ctx);
            });

            let deadFish = [];
            let eatenFish = []; 

            fishes.forEach(fish => {
                // Pass frameCount for logic throttling
                let status = fish.update(foodItems, fishes, frameCount); 
                fish.draw(ctx);
                
                if (status === 'gone') {
                    deadFish.push(fish);
                } else if (status === 'eaten') {
                    eatenFish.push(fish);
                    
                    for(let i=0; i<15; i++) { 
                        if(particles.length < 200) {
                            particles.push({
                                x: fish.pos.x, y: fish.pos.y,
                                vx: rand(-3,3), vy: rand(-3,3),
                                life: 1.0, color: '#E74C3C' 
                            });
                        }
                    }
                }
            });

            deadFish.forEach(fish => {
                const index = fishes.indexOf(fish);
                if (index > -1) {
                    addToGraveyard(fish);
                    fishes.splice(index, 1);
                }
            });
            
            eatenFish.forEach(fish => {
                const index = fishes.indexOf(fish);
                if (index > -1) {
                    addToGraveyard(fish); 
                    fishes.splice(index, 1);
                }
            });
            
            // Check for Game Over
            if (deadFish.length > 0 || eatenFish.length > 0) {
                checkGameOver();
            }

            // Optimized Particle Loop (Backwards)
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                
                if (p instanceof Food) {
                    if (p.eaten) {
                        particles.splice(i, 1); // Splice is okay for small food counts
                    }
                    continue;
                }
                
                if (p instanceof Bubble) {
                    p.update();
                    p.draw(ctx);
                    continue;
                }

                if (p.life) {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= 0.05;
                    
                    if (p.life <= 0) {
                        // OPTIMIZATION: Swap and pop is faster than splice for large arrays
                        // But order doesn't matter here, so it works perfect.
                        particles[i] = particles[particles.length - 1];
                        particles.pop();
                    } else {
                        ctx.fillStyle = p.color ? p.color : `rgba(255, 255, 255, ${p.life})`;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, 2, 0, Math.PI*2);
                        ctx.fill();
                    }
                }
            }
        }

        init();

    </script>
</body>
</html>
